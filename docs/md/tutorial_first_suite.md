# Writing Your First Test Suite
You just finished implementing a function with the following signature:

```
int rntoi(const char *value);
```

This function converts a string representation of Roman numerals into its
numeric value. It is similar to `atoi`, with the following exceptions:
* The entire string must be a valid roman numeral (unlike `atoi` which
  consumes as many characters as possible from the beginning of the
  string).
* Reports errors as negative values, not zero.

`rntoi` is located in a file named `romnum.c` (an example implementation can be
found in [`src/examples/romnum.c`](../../src/examples/romnum.c)).

## Writing Your First Test

The first test you want to write will verify that each Roman numeral with length
1 is properly parsed (i.e., verify the values associated with each letter are
correct).

The following code should handle this test case:
```c
#include <ctest/tests.h>

#include "romnum.h"

CT_TEST(valid_input)
{
	CT_ASSERT_INT_EQ(rntoi("i"), 1);
	CT_ASSERT_INT_EQ(rntoi("v"), 5);
	CT_ASSERT_INT_EQ(rntoi("x"), 10);
	CT_ASSERT_INT_EQ(rntoi("l"), 50);
	CT_ASSERT_INT_EQ(rntoi("c"), 100);
	CT_ASSERT_INT_EQ(rntoi("m"), 1000);
}

CT_SUITE_TESTS(romnum) {
	CT_SUITE_TEST(valid_input),
};
CT_SUITE(romnum);
```

(This test file can be found in
[`src/examples/simple_suite.c`](../../src/examples/simple_suite.c).)

This looks a lot like C, but there are some weird statements that don't quite
correspond to valid C syntax. Let's dive in each of these statements:

```c
#include <ctest/tests.h>
```


[`ctest/tests.h`](../../include/ctest/tests.h) contains the assertion macros and
macros for defining tests and test suites.  In almost all cases, this is the
only header file you'll need to include.

```c
CT_TEST(valid_input)
{
	CT_ASSERT_INT_EQ(rntoi("i"), 1);
	CT_ASSERT_INT_EQ(rntoi("v"), 5);
	CT_ASSERT_INT_EQ(rntoi("x"), 10);
	CT_ASSERT_INT_EQ(rntoi("l"), 50);
	CT_ASSERT_INT_EQ(rntoi("c"), 100);
	CT_ASSERT_INT_EQ(rntoi("m"), 1000);
}

```

The `CT_TEST` macro is used to define a single test; in this case a test named
`valid_input`. The `CT_TEST` macro is always followed by the body of the test.
Think of a test as a function that (typically) takes no parameters (more on that
[later](tutorial_data_providers.md)), returns no value, and consists of a
sequence of operational and verification steps. This particular test consists of
six assertions that will cause the test to fail if the assertions turn out to be
false. For now, it's not too important to understand all of the available
assertions; it's sufficient to understand that all assertions begin with
`CT_ASSERT_`. More information on available assertions can be found
[here](api.md).

```c
CT_SUITE_TESTS(romnum) {
	CT_SUITE_TEST(valid_input),
};
CT_SUITE(romnum);
```

The `CT_SUITE_TESTS` macro is used to collect all of the tests that will become
part of a suite. A suite is nothing more than a collection of related tests and
should correspond to a single translation unit (i.e., source file). In fact,
defining multiple suites in a single translation unit will result in a
compilation error. `CT_SUITE_TESTS` is supplied the name of the suite to which
the tests belong; in this case, a suite named `romnum`.

What follows `CT_SUITE_TESTS` is a list of tests to include in the suite. The
syntax here should look very much like array initialization (although that is
not completely obvious from this example). Each test is referenced using the
`CT_SUITE_TEST` macro, which is supplied the name of the test to reference (in
this case, `valid_input`. This *must* match the name of a test defined by the
`CT_TEST` macro. Tests are typically executed in the order provided here.

Finally, the `CT_SUITE` macro defines the suite; in this case, a suite named
`romnum`. This pulls in the tests specified by the list of tests with the same
name and registered the resulting suite. The tests defined by this translation
unit can now be called by `ctest` framework.

## Building Tests

Now that we've defined our test suite, we can build a suite module that can be
run by the execution framework. We can easily build a suite module using `gcc`:

```
gcc -shared -lcteststub romnum.o romnum_tests.c -o romnum_tests.so
```

It's not terribly important to understand what the entire command means, but
some `gcc` options are important, namely:
1. `romnum.o` is the object file generated by the code under test (your Roman
   numeral parser).
2. `romnum_tests.c` is the source file containing the tests suite and tests.
3. `romnum_test.so` is the output file (module) that will contain the compiled
   unit tests.

If all goes well, `romnum_tests.so` will be generated.

## Running Tests

Now that we've built our suite module, we can run the tests using the execution
framework. `ctest` has a rich API, making it easy to integrate into various
execution frameworks. However, it ships with a command line tool called
`ctester` that can run unit tests from a module. To run the tests from
`romnum_tests.so`, run the following command:

```
$ ctester run romnum_tests.so
romnum:valid_input ... OK
```

You can also run the tests directly from the examples in the source tree:

```
$ src/cli/ctester run src/examples/simple_suite.la
romnum:valid_input ... OK
```

## Getting Help
To learn about additional options, the `run` command accepts the `-h` option:

```
$ ctester run -h
usage: ../install/bin/ctester run [-n] suite [suite [...]]
       ../install/bin/ctester run -h

Summary:
    Run unit tests associated with each unit test suite.

    Where <suite> is the module file containing the suite.

    For a list of available tests within a suite, see the ls command.

Options:
    -n          Do not fork child processes to run the test. This is generally
                much faster, but may result in a failed tests impacting other
                tests. This is useful when running the tests in a debugger or
                memory leak detector.
    -h          Print this help message.
```

To learn about global options and/or available commands, `ctester` accepts the
`-h` option:

```
$ ctester -h
usage: ../install/bin/ctester [options] cmd ...
       ../install/bin/ctester cmd -h
       ../install/bin/ctester -h

Commands:
    run     Run unit tests.
    ls      List available unit tests.

Options:
    -h           Print this help message.
```

---

Next: [Upgrading Your Tests with Data](tutorial_data_providers.md)
